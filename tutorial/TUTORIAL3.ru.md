# На примере денег

## Часть третья

Мне кажется мы нарушаем последовательность разработки.
Сейчас у нас есть два класса, которые пока не приносят пользы,
поскольку не завязаны на выполнение бизнес функции.
Начинать разработку необходимо сверху.

В чем заключается бизнес ценность?
В книге это описывается довольно поверхностно.
Мы можем предположить, что у нас существует некоторый заказ (мне кажется это больше всего похоже на заказ).
Заказ состоит из позиций.
Каждая позиция имеет цену в определенной валюте и количество товара.
Нам необходимо подсчитать общую стоимость заказа в определенной валюте.

И здесь возникает интересный момент.
Я не понимаю, зачем нам могут понадобиться деньги, умноженные на n.
Поскольку для того, чтобы создать такие деньги, нам необходимы исходные данные сумма и n.
Эти исходные данные не могут взяться из ниоткуда.
И у нас есть источник этих данных. Это позиция заказа.
Когда мы у позиции зарашиваем стоимость этой позиции - она должна вернуть нам Money, соответствующий общей сумме.
И это не TimesMoney, зачем лишняя терминология? Это должен быть OrderItemMoney.
И multiplication должен быть не multiplication, а просто quantity.
И все встает на свои места.
Делаем рефакторинг.

```c++
class OrderItemMoney final : public Money {
public:
	OrderItemMoney(const std::shared_ptr<const Money> &money, int quantity);
	...
};

make_shared<EqualTest>(
	make_shared<MoneyText>(
		make_shared<OrderItemMoney>(
			make_shared<RealMoney>(5, "USD"),
			2
		)
	),
	"10 USD"
)
```

- [ ] $5 + 10CHF = $10 если курс обмена 2:1
- [x] $5 * 2 = $10
- [ ] Money это data class
- [ ] Преобразование Money в текст для отчета
- [ ] Общая сумма по всем позициям (простой случай)
- [x] Переименовать TimesMoney в OrderItemMoney со всеми вытекающими.

@todo #419 Create chapter 4 of Money example.

[Продолжить](TUTORIAL4.ru.md)
