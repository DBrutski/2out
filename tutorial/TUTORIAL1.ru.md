# На примере денег

Пример из книги TDD, Кента Бека

## Часть первая

- [ ] $5 + 10CHF = $10 if CHF:USD is 2:1
- [ ] $5 * 2 = $10

Второй пункт очевидно проще для начала.
Давайте напишем тест.

```c++
make_shared<EqualTest>(
	???,
	"10 USD"
)
```

В отличии от xUnit, где используется императивный подход, в oout нельзя просто взять и написать код.
На вход тесту необходимо передавать объект класса Text.
Любая тестируемая сущность должна быть объектом.
oout предлагает ряд решений для того, чтобы представить тестируемую сущность в виде текста.
Но иногда требуется создавать адаптеры для преобразования тестируемой сущности в Text.

Сам по себе объект типа Money вряд ли должен уметь превращаться в строку, хотя исходное задание предполагаем визуализацию этих объектов.
В с++ мы могли бы описать оператор вывода в поток, но мне, как адепту ООП, не очень нравится идея создавать отдельные методы.
Поэтому мы создадим класс MoneyText, с помощью которого будем визуализировать монеты в тестах.

И в первую очередь мы протестируем визуализацию

```c++
class MoneyText final : public oout::Text {
	string asString() const override
	{
		return to_string(money->amount()) + " " + money->currency();
	}
};

make_shared<EqualTest>(
	make_shared<MoneyText>(
		make_shared<Money>(5, "USD")
	),
	"5 USD"
)
```

Запускаем тесты - они работают.

```
[==========] Running 1 tests
[ RUN      ]
'5 USD' is equal '5 USD'
[       OK ]  (0 ms)
[==========] 1 tests ran.
[  PASSED  ] 1 test.
```

1. Сам по себе класс Money слишком примитивен, чтобы его показывать в туториале, это data class, и это проблема.
2. Написав адаптер MoneyText мы не решили проблему вывода Money в отчет. Сделаем это позже.

*Вопрос как в чистом ООП быть с датаклассами для меня открыт. Имплементации могут различаться. Какие-то из них могут иметь сложное поведение, какие-то примитивное. Это нормально.*

- [ ] Money это data class
- [ ] Преобразование Money в текст для отчета

[Продолжить](TUTORIAL2.ru.md)
